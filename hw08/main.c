#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/garbage.h"
#include "images/background.h"
#include "images/character.h"
#include "images/loser.h"
#include "images/winner.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state
{
  START,
  POSTSTART,
  PREPLAY,
  PLAY,
  WIN,
  LOSE,
  LOSE2,
};
void fillObstacles(struct obstacle arr[])
{
  struct obstacle o;
  o.color = WHITE;
  o.row = 0;
  o.col = 40;
  o.height = 10;
  o.width = 10;
  o.direction = -1;
  struct obstacle o1;
  o1.color = WHITE;
  o1.row = 30;
  o1.col = 90;
  o1.height = 10;
  o1.width = 10;
  o1.direction = -1;
  struct obstacle o2;
  o2.color = WHITE;
  o2.row = 60;
  o2.col = 120;
  o2.height = 10;
  o2.width = 10;
  o2.direction = -1;
  arr[0] = o;
  arr[1] = o1;
  arr[2] = o2;
}

int main(void)
{
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  struct player p;
  p.row = 0;
  p.col = 0;
  p.numDeaths = 0;
  struct player previous;
  previous.row = 0;
  previous.col = 0;
  previous.numDeaths = 0;

  struct obstacle obstacles[3];
  fillObstacles(obstacles);

  while (1)
  {
    currentButtons = BUTTONS; // Load the current state of the buttons
    char buffer[20];
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state)
    {
    case START:
      p.row = 0;
      p.col = 0;
      p.numDeaths = 0;
      fillObstacles(obstacles);
      break;
    case POSTSTART:
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
      {
        state = PREPLAY;
      }
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
      }
      break;
    case PREPLAY:
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
      }
      break;
    case PLAY:
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
      }
      sprintf(buffer, "Deaths: %d", p.numDeaths);
      previous.row = p.row;
      previous.col = p.col;
      for (int i = 0; i < 3; i++)
      {
        if (obstacles[i].direction > 0)
        {
          obstacles[i].row--;
        }
        else if (obstacles[i].direction < 0)
        {
          obstacles[i].row++;
        }
        if (obstacles[i].row == HEIGHT - obstacles[i].height || obstacles[i].row == 0)
        {
          obstacles[i].direction *= -1;
        }
        if ((p.col >= obstacles[i].col - 20 && p.col <= obstacles[i].col) && (p.row >= obstacles[i].row - 24 && p.row <= obstacles[i].row))
        {
          p.numDeaths++;
          state = LOSE;
          p.col = 0;
          p.row = 0;
        }
      }
      if (KEY_DOWN(BUTTON_DOWN, currentButtons) && p.row < (HEIGHT - 24))
      {
        p.row++;
      }
      if (KEY_DOWN(BUTTON_LEFT, currentButtons) && p.col > 0)
      {
        p.col--;
      }
      if (KEY_DOWN(BUTTON_UP, currentButtons) && p.row > 0)
      {
        p.row--;
      }
      if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && p.col <= (WIDTH - 20))
      {
        p.col++;
      }
      if (p.col > (WIDTH - 30))
      {
        p.col = 0;
        p.row = 0;
        state = WIN;
      }
      break;
    case WIN:
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
      }
      // state = ?
      break;
    case LOSE:
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
      }
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
      {
        state = PREPLAY;
      }
      break;
    case LOSE2:
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
      }
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
      {
        state = PREPLAY;
      }
      break;
    }

    waitForVBlank();

    switch (state)
    {
    case START:
      p.row = 0;
      p.col = 0;
      p.numDeaths = 0;
      drawFullScreenImageDMA(background);
      drawString(50, 60, "World's Hardest Game", WHITE);
      drawString(80, 60, "Press Start To Play", WHITE);
      state = POSTSTART;
      break;
    case POSTSTART:
      break;
    case PREPLAY:
      fillScreenDMA(BLACK);
      drawRectDMA(0, 230, 10, HEIGHT, GREEN);
      state = PLAY;
      break;
    case PLAY:
      drawRectDMA(previous.row, previous.col, 20, 24, BLACK);
      for (int i = 0; i < 3; i++)
      {
        drawRectDMA(obstacles[i].row + obstacles[i].direction, obstacles[i].col, obstacles[i].width, obstacles[i].height, BLACK);
      }
      drawImageDMA(p.row, p.col, 20, 24, character);
      drawString(140, 90, buffer, WHITE);
      drawString(140, 90, buffer, WHITE);
      for (int i = 0; i < 3; i++)
      {
        drawRectDMA(obstacles[i].row, obstacles[i].col, obstacles[i].width, obstacles[i].height, obstacles[i].color);
      }
      break;
    case WIN:
      drawFullScreenImageDMA(winner);
      drawString(140, 90, buffer, WHITE);
      // state = ?
      break;
    case LOSE:
      drawFullScreenImageDMA(loser);
      state = LOSE2;
      break;
    case LOSE2:
      break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
